#' Table results
#'
#' Computes marginal means and their comparisons of
#' a set of regression models and tables the results.
#'
#' @param fits List. Model fits such as those generated
#'   by \code{fit_models}.
#' @param specs Tibble or data.frame. Contains research
#'   questions operationalisation.
#' @param sets Tibble. Contains variable sets mapping to
#'   table labels. E.g., generated by \code{adjustment_table}.
#' @param CIs Logical. Should CIs be returned (`TRUE`, default)
#'   or SEs (`FALSE`)?
#'
#' @returns A tibble with formatted marginal means and their
#'   comparisons.
#'
#' @export
stat_test <- function(fits, specs, sets, CIs = TRUE) {
  # Extract & compare marginal means:
  emm <- est <- comp <- list()
  for (i in names(fits)) {
    mods <- fits[[i]]
    mod_specs <- subset(specs, estimate == i)
    if (i == "g-computation") {
      est[[i]] <- compute_predictions(mods, mod_specs)
      comp[[i]] <- g_computations(mods, mod_specs)
    } else {
      emm[[i]] <- compute_means(mods, mod_specs)
      est[[i]] <- extract_means(emm[[i]], mod_specs)
      comp[[i]] <- compare_means(emm[[i]], mod_specs)
    }
  }
  # Do residual checks:
  check <- lapply(rlang::set_names(names(fits)), function(i) {
    purrr::map_dbl(rlang::set_names(names(fits[[i]])), function(j) {
      if (i == "g-computation") {
        NA # Skip in case of g-computation as the check fails due to weights.
      } else {
        performance::check_residuals(fits[[i]][[j]]) |>
          as.numeric()
      }
    }) |>
      tibble::enframe(name = "fit", value = "residual_check_p") |>
      tidyr::separate(
        fit,
        into = c("y", "x", "m"),
        sep = "\\s*~\\s*|\\s*\\|\\s*",
        remove = TRUE,
        convert = TRUE
      ) |>
      dplyr::mutate(residual_check_sig = dplyr::if_else(
        residual_check_p < .05, "!", ""
      ))
  })
  # Extract outcome to analysis type mapping:
  map_analysis <- specs |>
    dplyr::select(outcome, analysis) |>
    dplyr::distinct()
  # Make tables:
  lapply(rlang::set_names(names(fits)), function(t) {
    lapply(rlang::set_names(unique(est[[t]]$x)), function(i) {
      estimate <- ifelse(CIs, "Est_CI", "Est_SE")
      drop <- ifelse(CIs, "Est_SE", "Est_CI")
      est[[t]] |>
        dplyr::filter(x == i) |>
        dplyr::filter(m == "1") |> # main effects only ----
        dplyr::select(-tidyselect::all_of(drop)) |>
        tidyr::pivot_wider(
          values_from = estimate,
          names_from = "group",
          names_prefix = glue::glue("{i} = ")
        ) |>
        dplyr::left_join(
          comp[[t]],
          by = dplyr::join_by(x, y, m, mod)
        ) |>
        dplyr::left_join(
          check[[t]],
          by = dplyr::join_by(x, y, m)
        ) |>
        dplyr::mutate(
          analysis = unlist(
            sapply(seq_len(dplyr::n()), function(i) {
              subset(map_analysis, outcome == y[i])$analysis
            }),
            use.names = FALSE
          )
        ) |>
        dplyr::group_by(analysis) |>
        dplyr::mutate(sig_FDR = bh_adjust(p.value)) |> # Adjust p-values per analysis type.
        dplyr::ungroup() |>
        dplyr::mutate(
          Variable = factor(
            sapply(seq_len(dplyr::n()), function(i) {
              unique(sets[stringr::str_detect(sets$Y, y[i]), "outcome"])
            }),
            levels = c("Cognition", "Affect", "cPA"),
            ordered = TRUE
          ),
          sig. = dplyr::if_else(p.value < .05, "*", ""),
          m = dplyr::if_else(mod == "overall", "", glue::glue("{m} = {mod}")),
          Contrast = dplyr::if_else(
            rep(CIs, dplyr::n()),
            true = glue::glue("{rprint(Estimate, 2)} [{rprint(conf.low, 2)}, {rprint(conf.high, 2)}]"),
            false = glue::glue("{rprint(Estimate, 2)} ({rprint(SE, 2)})")
          ),
          s.value = -log2(p.value),
          Statistic = rprint(statistic, 3),
          `p value` = zerolead(p.value),
          residual_check_p = zerolead(residual_check_p)
        ) |>
        dplyr::rename(
          "Outcome" = "y",
          "Exposure" = "x",
          "Moderator" = "m",
          "Comparison" = "contrast"
        ) |>
        dplyr::select(
          Variable, Outcome, Exposure, Moderator, tidyselect::contains(i),
          Comparison, Contrast, Statistic, df, tidyselect::ends_with(".value"),
          `p value`, sig., sig_FDR, tidyselect::starts_with("residual")
        )
    })
  })
}
