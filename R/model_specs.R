#' Set models' specifications
#'
#' Using table of adjustments derived via \code{adjustment_table},
#' this function prepares model specifications for later fitting.
#'
#' @param table Tibble. Generated by \code{adjustment_table}.
#'
#' @return A tibble with following columns:
#'
#' @export
model_specs <- function(table) {
  purrr::map_dfr(seq_len(nrow(table)), function(i) {
    Y_set <- remove_brackets(table[i, "Y"]) |>
      unlist(use.names = FALSE)
    Y_vec <- strsplit(Y_set, ", ", fixed = TRUE)[[1]]
    purrr::map_dfr(Y_vec, function(y) {
      tibble::tibble(
        outcome = y,
        exposure = table[i, ]$exposure,
        moderator = dplyr::if_else(
          is.na(table[i, "moderator"]),
          true = "1",
          false = as.character(table[i, "moderator"])
        ),
        term = table[i , ]$term,
        likelihood = dplyr::case_when(
          y %in% c("MMSE", "Z_SA", "GDS15", "GAI", "FAQ") ~ "gaussian",
          stringr::str_detect(y, "_z") ~ "gaussian",
          y %in% c("SA", "cPA", "Depr", "Anx") ~ "binomial"
        ),
        matching = table[i, ]$matching,
        unadjusted = paste(y, table[i, "term"], sep = " ~ "),
        adjusted = paste(y, table[i, "X"], sep = " ~ ")
      ) |>
        dplyr::mutate(
          transformed = dplyr::case_when(
            likelihood == "gaussian" ~ paste0(y, "_trans ~ ", table[i, "X"]),
            .default = adjusted
          ),
          #`g-computation` = transformed,
          analysis = dplyr::case_when(
            y == "MMSE" ~ 0,
            stringr::str_detect(y, "_z") ~ 2,
            .default = 1
          )
        )
    })
  }) |>
    tidyr::pivot_longer(
      #cols = c("unadjusted", "adjusted", "transformed", "g-computation"),
      cols = c("unadjusted", "adjusted", "transformed"),
      values_to = "formula",
      names_to = "estimate"
    )
}
